//------------------------------------------------
//--- 010 Editor v10.0.2 Binary Template
//
//      File: esx.bt
//   Authors: Greatness7, NullCascade
//   Version: in-dev
//   Purpose: Providing aided binary reading of ESP, ESM, and ESS files for Morrowind.
//  Category: Games
// File Mask:
//  ID Bytes:
//   History: See GIT.
//------------------------------------------------

LittleEndian();

/*

	Core types are defined first, and are the scaffolding for everything else. Local variables
	allow overriding the display name and value, as well as the comment. Two areas of
	statements can be extended to include more data types:

	First, just below in the Subrecord definition, new record types can be defined. These all
	point to a factory function that determines how the individual subrecords load what they
	need.

	Below the core type definitions are individual record definitions. These define a switch
	statement for individual subrecords (or whatever other logic is neccessary).

 */

//
// Core types.
//

// Subrecord
typedef struct {
	char tag[4];
	uint32 size;

	// Local variables for display overrides.
	local string displayName = tag;
	local string displayValue = "";
	local string comment = "";

	switch (parentof(this).tag) {
		//! Expand this table to add more record types.
		case "TES3": SubrecordFactory_TES3(this); break;  //
		case "GMST": SubrecordFactory_GMST(this); break;  // Game Setting
		case "GLOB": SubrecordFactory_GLOB(this); break;  // Global Variable
		case "CLAS": SubrecordFactory_CLAS(this); break;  // Class
		case "FACT": SubrecordFactory_FACT(this); break;  // Faction
		case "RACE": SubrecordFactory_RACE(this); break;  // Race
		case "SOUN": SubrecordFactory_SOUN(this); break;  // Sound
		case "SKIL": SubrecordFactory_SKIL(this); break;  // Skill
		case "MGEF": SubrecordFactory_MGEF(this); break;  // Magic Effect
		case "SCPT": SubrecordFactory_SCPT(this); break;  // Script
		case "REGN": SubrecordFactory_REGN(this); break;  // Region
		case "BSGN": SubrecordFactory_BSGN(this); break;  // Birthsign
		case "LTEX": SubrecordFactory_LTEX(this); break;  // Land Texture
		case "STAT": SubrecordFactory_STAT(this); break;  // Static
		case "DOOR": SubrecordFactory_DOOR(this); break;  // Door
		case "MISC": SubrecordFactory_MISC(this); break;  // Misc. Item
		// case "WEAP": SubrecordFactory_WEAP(this); break;
		// case "CONT": SubrecordFactory_CONT(this); break;
		// case "SPEL": SubrecordFactory_SPEL(this); break;
		// case "CREA": SubrecordFactory_CREA(this); break;
		// case "BODY": SubrecordFactory_BODY(this); break;
		// case "LIGH": SubrecordFactory_LIGH(this); break;
		// case "ENCH": SubrecordFactory_ENCH(this); break;
		// case "NPC_": SubrecordFactory_NPC_(this); break;
		// case "ARMO": SubrecordFactory_ARMO(this); break;
		// case "CLOT": SubrecordFactory_CLOT(this); break;
		// case "REPA": SubrecordFactory_REPA(this); break;
		// case "ACTI": SubrecordFactory_ACTI(this); break;
		// case "APPA": SubrecordFactory_APPA(this); break;
		// case "LOCK": SubrecordFactory_LOCK(this); break;
		// case "PROB": SubrecordFactory_PROB(this); break;
		// case "INGR": SubrecordFactory_INGR(this); break;
		// case "BOOK": SubrecordFactory_BOOK(this); break;
		// case "ALCH": SubrecordFactory_ALCH(this); break;
		// case "LEVI": SubrecordFactory_LEVI(this); break;
		// case "LEVC": SubrecordFactory_LEVC(this); break;
		// case "CELL": SubrecordFactory_CELL(this); break;
		// case "LAND": SubrecordFactory_LAND(this); break;
		// case "PGRD": SubrecordFactory_PGRD(this); break;
		// case "SNDG": SubrecordFactory_SNDG(this); break;
		// case "DIAL": SubrecordFactory_DIAL(this); break;
		case "INFO": SubrecordFactory_INFO(this); break;  // Dialogue Info
		case "SSCR": SubrecordFactory_SSCR(this); break;  // Start Script
		default: byte undefined[size];
	}
} Subrecord <name=Subrecord_GetDisplayName, read=Subrecord_Read, comment=Subrecord_GetComment>;

string Subrecord_GetDisplayName(Subrecord& sr) {
	return sr.displayName;
}

int Subrecord_GetSize(Subrecord& sr) {
	return 8 + ReadUInt(startof(sr)+4);
}

string Subrecord_Read(Subrecord& sr) {
	return sr.displayValue;
}

string Subrecord_GetComment(Subrecord& sr) {
	return sr.comment;
}

// Record
typedef struct {
	char tag[4];
	uint32 size;
	uint32 header1;
	uint32 flags;

	// Local variables for display overrides.
	local string displayName = tag;
	local string displayValue = "";
	local string comment = "";

	// Read subrecords
	while (FTell() < startof(this) + 16 + size) {
		Subrecord subrecord;
	}
} Record <name=Record_GetDisplayName, read=Record_Read, comment=Record_GetComment, size=Record_GetSize, optimize=false>;

string Record_GetDisplayName(Record& r) {
	return r.displayName;
}

int Record_GetSize(Record& r) {
	return 16 + ReadUInt(startof(r)+4);
}

string Record_Read(Record& r) {
	return r.displayValue;
}

string Record_GetComment(Record& r) {
	return r.comment;
}

//
// Utility functions/types.
//



//
// Record: TES3
//

typedef enum <uint> {
	ESP = 0,
	ESM = 1,
	ESS = 32,
} ESFileType;

void SubrecordFactory_TES3_HEDR(Subrecord& sr) {
	float version <comment="Should always be 1.2">;
	ESFileType fileType;
	char companyName[32];
	char description[256];
	uint recordCount;

	parentof(sr).comment = description;
}

void SubrecordFactory_TES3(Subrecord& sr) {
	switch (sr.tag) {
		case "HEDR": SubrecordFactory_TES3_HEDR(sr); break;
		default: byte undefined[sr.size];
	}
}

//
// Record: GMST (Game Setting)
//

void GMST_NAME(Subrecord& sr) {
	char name[sr.size];
	sr.displayName = "ID";
	sr.displayValue = name;
	parentof(sr).displayName = "Game Setting: " + name;
}

void GMST_STRV(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "Value";
	sr.displayValue = value;
	parentof(sr).displayValue = value;
}

void GMST_INTV(Subrecord& sr) {
	int value;
	sr.displayName = "Value";
	SPrintf(sr.displayValue, "%d", value);
	parentof(sr).displayValue = sr.displayValue;
}

void GMST_FLTV(Subrecord& sr) {
	float value;
	sr.displayName = "Value";
	SPrintf(sr.displayValue, "%.4f", value);
	parentof(sr).displayValue = sr.displayValue;
}

void SubrecordFactory_GMST(Subrecord& sr) {
	switch (sr.tag) {
		case "NAME": GMST_NAME(sr); break;
		case "STRV": GMST_STRV(sr); break;
		case "INTV": GMST_INTV(sr); break;
		case "FLTV": GMST_FLTV(sr); break;
		default: byte undefined[sr.size];
	}
}

//
// Record: GLOB (Global Variable)
//

void GLOB_NAME(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "ID";
	sr.displayValue = value;
	parentof(sr).displayName = "Global Variable: " + value;
}

void GLOB_FNAM(Subrecord& sr) {
	char value;
	sr.displayName = "Type";
	sr.displayValue = value;
}

void GLOB_FLTV(Subrecord& sr) {
	float value;
	sr.displayName = "Value";
	SPrintf(sr.displayValue, "%.4f", value);
	parentof(sr).displayValue = sr.displayValue;
}

void SubrecordFactory_GLOB(Subrecord& sr) {
	switch (sr.tag) {
		case "NAME": GLOB_NAME(sr); break;
		case "FNAM": GLOB_FNAM(sr); break;
		case "FLTV": GLOB_FLTV(sr); break;
		default: byte undefined[sr.size];
	}
}

//
// Record: CLAS (Class)
//

typedef enum {
	ATTRIBUTE_NONE = -1,
	ATTRIBUTE_STRENGTH,
	ATTRIBUTE_INTELLIGENCE,
	ATTRIBUTE_WILLPOWER,
	ATTRIBUTE_AGILITY,
	ATTRIBUTE_SPEED,
	ATTRIBUTE_ENDURANCE,
	ATTRIBUTE_PERSONALITY,
	ATTRIBUTE_LUCK,
} Attribute;

typedef enum {
	SPECIALIZATION_NONE = -1,
	SPECIALIZATION_COMBAT,
	SPECIALIZATION_MAGIC,
	SPECIALIZATION_STEALTH,
} Specialization;

typedef enum {
	SKILL_NONE = -1,
	SKILL_BLOCK,
	SKILL_ARMORER,
	SKILL_MEDIUM_ARMOR,
	SKILL_HEAVY_ARMOR,
	SKILL_BLUNT_WEAPON,
	SKILL_LONG_BLADE,
	SKILL_AXE,
	SKILL_SPEAR,
	SKILL_ATHLETICS,
	SKILL_ENCHANT,
	SKILL_DESTRUCTION,
	SKILL_ALTERATION,
	SKILL_ILLUSION,
	SKILL_CONJURATION,
	SKILL_MYSTICISM,
	SKILL_RESTORATION,
	SKILL_ALCHEMY,
	SKILL_UNARMORED,
	SKILL_SECURITY,
	SKILL_SNEAK,
	SKILL_ACROBATICS,
	SKILL_LIGHT_ARMOR,
	SKILL_SHORT_BLADE,
	SKILL_MARKSMAN,
	SKILL_MERCANTILE,
	SKILL_SPEECHCRAFT,
	SKILL_HAND_TO_HAND,
} Skill;

void CLAS_NAME(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "ID";
	sr.displayValue = value;
	parentof(sr).displayName = "Class: " + value;
}

void CLAS_FNAM(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "Name";
	sr.displayValue = value;
}

void CLAS_CLDT(Subrecord& sr) {
	Attribute attributeId1;
	Attribute attributeId2;
	Specialization specialization;
	Skill minor1;
	Skill major1;
	Skill minor2;
	Skill major2;
	Skill minor3;
	Skill major3;
	Skill minor4;
	Skill major4;
	Skill minor5;
	Skill major5;
	uint classFlags;
	uint autoCalcFlags;
	sr.displayName = "Class Data";
}

void CLAS_DESC(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "Description";
	sr.displayValue = value;
}

void SubrecordFactory_CLAS(Subrecord& sr) {
	switch (sr.tag) {
		case "NAME": CLAS_NAME(sr); break;
		case "FNAM": CLAS_FNAM(sr); break;
		case "CLDT": CLAS_CLDT(sr); break;
		case "DESC": CLAS_DESC(sr); break;
		default: byte undefined[sr.size];
	}
}

//
// Record: FACT (Faction)
//

void FACT_NAME(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "ID";
	sr.displayValue = value;
	parentof(sr).displayName = "Faction: " + value;
}

void FACT_FNAM(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "Name";
	sr.displayValue = value;
}

void FACT_RNAM(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "Rank Name";
	sr.displayValue = value;
}

void FACT_FADT(Subrecord& sr) {
	Attribute attributeId1;
	Attribute attributeId2;
	struct {
		int reqAttributes[2];
		int requiredSkills[2];
		int factionReputation;
	} rankData[10] <name="Rank Data">;
	Skill skills[7];
	uint flags;
	sr.displayName = "Faction Data";
}

void FACT_ANAM(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "Reaction Faction";
	sr.displayValue = value;
}

void FACT_INTV(Subrecord& sr) {
	int value;
	sr.displayName = "Reaction Adjustment";
	SPrintf(sr.displayValue, "%d", value);
}

void SubrecordFactory_FACT(Subrecord& sr) {
	switch (sr.tag) {
		case "NAME": FACT_NAME(sr); break;
		case "FNAM": FACT_FNAM(sr); break;
		case "RNAM": FACT_RNAM(sr); break;
		case "FADT": FACT_FADT(sr); break;
		case "ANAM": FACT_ANAM(sr); break;
		case "INTV": FACT_INTV(sr); break;
		default: byte undefined[sr.size];
	}
}

//
// Record: RACE (Race)
//

void RACE_NAME(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "ID";
	sr.displayValue = value;
	parentof(sr).displayName = "Race: " + value;
}

void RACE_FNAM(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "Name";
	sr.displayValue = value;
}

void RACE_RADT(Subrecord& sr) {
	struct {
		Skill skill;
		int bonus;
	} skillBonuses[7];
	int strength[2];
	int intelligence[2];
	int willpower[2];
	int agility[2];
	int speed[2];
	int endurance[2];
	int personality[2];
	int luck[2];
	float height[2];
	float weight[2];
	uint flags;
}

void RACE_NPCS(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "Special Power/Ability";
	sr.displayValue = value;
}

void RACE_DESC(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "Description";
	sr.displayValue = value;
}

void SubrecordFactory_RACE(Subrecord& sr) {
	switch (sr.tag) {
		case "NAME": RACE_NAME(sr); break;
		case "FNAM": RACE_FNAM(sr); break;
		case "RADT": RACE_RADT(sr); break;
		case "NPCS": RACE_NPCS(sr); break;
		case "DESC": RACE_DESC(sr); break;
		default: byte undefined[sr.size];
	}
}

//
// Record: SOUN (Sound)
//

void SOUN_NAME(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "ID";
	sr.displayValue = value;
	parentof(sr).displayName = "Sound: " + value;
}

void SOUN_FNAM(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "Filename";
	sr.displayValue = value;
	sr.comment = "Relative to Data Files\\Sounds\\";
}

void SOUN_DATA(Subrecord& sr) {
	ubyte volume <comment="0=0.00, 255=1.00">;
	ubyte rangeMin;
	ubyte rangeMax;
	sr.displayName = "Sound Data";
}

void SubrecordFactory_SOUN(Subrecord& sr) {
	switch (sr.tag) {
		case "NAME": SOUN_NAME(sr); break;
		case "FNAM": SOUN_FNAM(sr); break;
		case "DATA": SOUN_DATA(sr); break;
		default: byte undefined[sr.size];
	}
}

//
// Record: SKIL (Skill)
//

void SKIL_INDX(Subrecord& sr) {
	int value;
	sr.displayName = "ID";
	SPrintf(sr.displayValue, "%d", value);
	parentof(sr).displayName = "Skill: " + sr.displayValue;
}

void SKIL_SKDT(Subrecord& sr) {
	Attribute attribute;
	Specialization specialization;
	float experienceValues[4];
	sr.displayName = "Skill Data";
}

void SKIL_DESC(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "Description";
	sr.displayValue = value;
}

void SubrecordFactory_SKIL(Subrecord& sr) {
	switch (sr.tag) {
		case "INDX": SKIL_INDX(sr); break;
		case "SKDT": SKIL_SKDT(sr); break;
		case "DESC": SKIL_DESC(sr); break;
		default: byte undefined[sr.size];
	}
}

//
// Record: MGEF (Magic Effect)
//

typedef enum {
	SCHOOL_ALTERATION,
	SCHOOL_CONJURATION,
	SCHOOL_DESTRUCTION,
	SCHOOL_ILLUSION,
	SCHOOL_MYSTICISM,
	SCHOOL_RESTORATION,
} SpellSchool;

void MGEF_INDX(Subrecord& sr) {
	int value;
	sr.displayName = "ID";
	SPrintf(sr.displayValue, "%d", value);
	parentof(sr).displayName = "Magic Effect: " + sr.displayValue;
}

void MGEF_MEDT(Subrecord& sr) {
	SpellSchool school;
	float baseCost;
	uint flags;
	int rgb[3];
	float speed;
	float sizeIncrease;
	float sizeCap;
	sr.displayName = "EFfect Data";
}

void MGEF_ITEX(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "Icon";
	sr.displayValue = value;
}

void MGEF_PTEX(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "Particle Texture";
	sr.displayValue = value;
}

void MGEF_CVFX(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "Casting Visual";
	sr.displayValue = value;
}

void MGEF_BVFX(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "Bolt Visual";
	sr.displayValue = value;
}

void MGEF_HVFX(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "Hit Visual";
	sr.displayValue = value;
}

void MGEF_AVFX(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "Area Visual";
	sr.displayValue = value;
}

void MGEF_DESC(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "Description";
	sr.displayValue = value;
}

void MGEF_CSND(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "Cast Sound";
	sr.displayValue = value;
}

void MGEF_BSND(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "Bolt Sound";
	sr.displayValue = value;
}

void MGEF_HSND(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "Hit Sound";
	sr.displayValue = value;
}

void MGEF_ASND(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "Area Sound";
	sr.displayValue = value;
}

void SubrecordFactory_MGEF(Subrecord& sr) {
	switch (sr.tag) {
		case "INDX": MGEF_INDX(sr); break;
		case "MEDT": MGEF_MEDT(sr); break;
		case "ITEX": MGEF_ITEX(sr); break;
		case "PTEX": MGEF_PTEX(sr); break;
		case "CVFX": MGEF_CVFX(sr); break;
		case "BVFX": MGEF_BVFX(sr); break;
		case "HVFX": MGEF_HVFX(sr); break;
		case "AVFX": MGEF_AVFX(sr); break;
		case "DESC": MGEF_DESC(sr); break;
		case "CSND": MGEF_CSND(sr); break;
		case "BSND": MGEF_BSND(sr); break;
		case "HSND": MGEF_HSND(sr); break;
		case "ASND": MGEF_ASND(sr); break;
		default: byte undefined[sr.size];
	}
}

//
// Record: SCPT (Script)
//

void SCPT_SCHD(Subrecord& sr) {
	char id[32];
	uint numShorts;
	uint numLongs;
	uint numFloats;
	uint scriptDataSize;
	uint localVarSize;
	sr.displayName = "Script Data";
	sr.displayValue = id;
	parentof(sr).displayName = "Script: " + sr.displayValue;
}

void SCPT_SCVR(Subrecord& sr) {
	char elements[sr.size];
	sr.displayName = "Script Variables";
}

void SCPT_SCDT(Subrecord& sr) {
	byte value[sr.size];
	sr.displayName = "Compiled Script";
}

void SCPT_SCTX(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "Script Text";
}

void SubrecordFactory_SCPT(Subrecord& sr) {
	switch (sr.tag) {
		case "SCHD": SCPT_SCHD(sr); break;
		case "SCVR": SCPT_SCVR(sr); break;
		case "SCDT": SCPT_SCDT(sr); break;
		case "SCTX": SCPT_SCTX(sr); break;
		default: byte undefined[sr.size];
	}
}

//
// Record: REGN (Region)
//

void REGN_NAME(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "ID";
	sr.displayValue = value;
	parentof(sr).displayName = "Region: " + sr.displayValue;
}

void REGN_FNAM(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "Name";
	sr.displayValue = value;
}

void REGN_WEAT(Subrecord& sr) {
	ubyte chanceClear;
	ubyte chanceCloudy;
	ubyte chanceFoggy;
	ubyte chanceOvercast;
	ubyte chanceRain;
	ubyte chanceThunder;
	ubyte chanceAsh;
	ubyte chanceBlight;
	sr.displayName = "Weather Chances";
}

void REGN_BNAM(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "Sleep Encounter";
	sr.displayValue = value;
}

void REGN_CNAM(Subrecord& sr) {
	ubyte red;
	ubyte green;
	ubyte blue;
	ubyte alpha <comment="Potentially unused">;
	sr.displayName = "Map Color";
	SPrintf(sr.displayValue, "(%d,%d,%d)", red, green, blue);
}

void REGN_SNAM(Subrecord& sr) {
	char soundId[32];
	ubyte chance;
	sr.displayName = "Sound";
	SPrintf(sr.displayValue, "%s (%d)", soundId, chance);
}

void SubrecordFactory_REGN(Subrecord& sr) {
	switch (sr.tag) {
		case "NAME": REGN_NAME(sr); break;
		case "FNAM": REGN_FNAM(sr); break;
		case "WEAT": REGN_WEAT(sr); break;
		case "BNAM": REGN_BNAM(sr); break;
		case "CNAM": REGN_CNAM(sr); break;
		case "SNAM": REGN_SNAM(sr); break;
		default: byte undefined[sr.size];
	}
}

//
// Record: BSGN (Birthsign)
//

void BSGN_NAME(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "ID";
	sr.displayValue = value;
	parentof(sr).displayName = "Birthsign: " + sr.displayValue;
}

void BSGN_FNAM(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "Name";
	sr.displayValue = value;
}

void BSGN_TNAM(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "Texture";
	sr.displayValue = value;
}

void BSGN_DESC(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "Description";
	sr.displayValue = value;
}

void BSGN_NPCS(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "Special Power/Ability";
	sr.displayValue = value;
}

void SubrecordFactory_BSGN(Subrecord& sr) {
	switch (sr.tag) {
		case "NAME": BSGN_NAME(sr); break;
		case "FNAM": BSGN_FNAM(sr); break;
		case "TNAM": BSGN_TNAM(sr); break;
		case "DESC": BSGN_DESC(sr); break;
		case "NPCS": BSGN_NPCS(sr); break;
		default: byte undefined[sr.size];
	}
}

//
// Record: LTEX (Land Texture)
//

void LTEX_NAME(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "ID";
	sr.displayValue = value;
	parentof(sr).displayName = "Land Texture: " + sr.displayValue;
}

void LTEX_INTV(Subrecord& sr) {
	int value;
	SPrintf(sr.displayValue, "%d", value);
}

void LTEX_DATA(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "Texture";
	sr.displayValue = value;
}

void SubrecordFactory_LTEX(Subrecord& sr) {
	switch (sr.tag) {
		case "NAME": LTEX_NAME(sr); break;
		case "INTV": LTEX_INTV(sr); break;
		case "DATA": LTEX_DATA(sr); break;
		default: byte undefined[sr.size];
	}
}

//
// Record: STAT (Static Object)
//

void STAT_NAME(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "ID";
	sr.displayValue = value;
	parentof(sr).displayName = "Static: " + sr.displayValue;
}

void STAT_MODL(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "Model";
	sr.displayValue = value;
}

void SubrecordFactory_STAT(Subrecord& sr) {
	switch (sr.tag) {
		case "NAME": STAT_NAME(sr); break;
		case "MODL": STAT_MODL(sr); break;
		default: byte undefined[sr.size];
	}
}

//
// Record: DOOR (Door Object)
//

void DOOR_NAME(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "ID";
	sr.displayValue = value;
	parentof(sr).displayName = "Door: " + sr.displayValue;
}

void DOOR_FNAM(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "Name";
	sr.displayValue = value;
}

void DOOR_MODL(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "Model";
	sr.displayValue = value;
}

void DOOR_SCIP(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "Script";
	sr.displayValue = value;
}

void DOOR_SNAM(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "Open Sound";
	sr.displayValue = value;
}

void DOOR_ANAM(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "Close Sound";
	sr.displayValue = value;
}

void SubrecordFactory_DOOR(Subrecord& sr) {
	switch (sr.tag) {
		case "NAME": DOOR_NAME(sr); break;
		case "FNAM": DOOR_FNAM(sr); break;
		case "MODL": DOOR_MODL(sr); break;
		case "SCIP": DOOR_SCIP(sr); break;
		case "SNAM": DOOR_SNAM(sr); break;
		case "ANAM": DOOR_ANAM(sr); break;
		default: byte undefined[sr.size];
	}
}

//
// Record: MISC (Miscellaneous Object)
//

void MISC_NAME(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "ID";
	sr.displayValue = value;
	parentof(sr).displayName = "Misc. Item: " + sr.displayValue;
}

void MISC_MODL(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "Model";
	sr.displayValue = value;
}

void MISC_FNAM(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "Name";
	sr.displayValue = value;
}

void MISC_MCDT(Subrecord& sr) {
	float weight;
	int value;
	uint flags;
	sr.displayName = "Data";
}

void MISC_ITEX(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "Inventory Icon";
	sr.displayValue = value;
}

void MISC_ENAM(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "Enchantment";
	sr.displayValue = value;
}

void MISC_SCRI(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "Script";
	sr.displayValue = value;
}

void SubrecordFactory_MISC(Subrecord& sr) {
	switch (sr.tag) {
		case "NAME": MISC_NAME(sr); break;
		case "MODL": MISC_MODL(sr); break;
		case "FNAM": MISC_FNAM(sr); break;
		case "MCDT": MISC_MCDT(sr); break;
		case "ITEX": MISC_ITEX(sr); break;
		case "ENAM": MISC_ENAM(sr); break;
		case "SCRI": MISC_SCRI(sr); break;
		default: byte undefined[sr.size];
	}
}

//
// Record: INFO (Dialogue Info)
//

typedef enum <byte> {
	SEX_ANY = -1,
	SEX_MALE,
	SEX_FEMALE,
} Sex;

typedef enum {
	TYPE_TOPIC,
	TYPE_VOICE,
	TYPE_GREETING,
	TYPE_PERSUASION,
	TYPE_JOURNAL,
} DialogueType;

typedef enum <char> {
	VAR_NONE = '0',
	VAR_FUNCTION = '1',
	VAR_GLOBAL = '2',
	VAR_LOCAL = '3',
	VAR_JOURNAL = '4',
	VAR_ITEM = '5',
	VAR_DEAD = '6',
	VAR_NOT_ID = '7',
	VAR_NOT_FACTION = '8',
	VAR_NOT_CLASS = '9',
	VAR_NOT_RACE = 'A',
	VAR_NOT_CELL = 'B',
	VAR_NOT_LOCAL = 'C',
} DialogueVarType;

typedef enum <ushort> {
	FUNC_REACTION_LOW = 12336,            // '00',
	FUNC_REACTION_HIGH = 12592,           // '01',
	FUNC_RANK_REQUIREMENT = 12848,        // '02',
	FUNC_REPUTATION = 13104,              // '03',
	FUNC_HEALTH_PERCENT = 13360,          // '04',
	FUNC_PC_REPUTATION = 13616,           // '05',
	FUNC_PC_LEVEL = 13872,                // '06',
	FUNC_PC_HEALTH_PERCENT = 14128,       // '07',
	FUNC_PC_MAGICKA = 14384,              // '08',
	FUNC_PC_FATIGUE = 14640,              // '09',
	FUNC_PC_STRENGTH = 12337,             // '10',
	FUNC_PC_BLOCK = 12593,                // '11',
	FUNC_PC_ARMORER = 12849,              // '12',
	FUNC_PC_MEDIUM_ARMOR = 13105,         // '13',
	FUNC_PC_HEAVY_ARMOR = 13361,          // '14',
	FUNC_PC_BLUNT_WEAPON = 13617,         // '15',
	FUNC_PC_LONG_BLADE = 13873,           // '16',
	FUNC_PC_AXE = 14129,                  // '17',
	FUNC_PC_SPEAR = 14385,                // '18',
	FUNC_PC_ATHLETICS = 14641,            // '19',
	FUNC_PC_ENCHANT = 12338,              // '20',
	FUNC_PC_DESTRUCTION = 12594,          // '21',
	FUNC_PC_ALTERATION = 12850,           // '22',
	FUNC_PC_ILLUSION = 13106,             // '23',
	FUNC_PC_CONJURATION = 13362,          // '24',
	FUNC_PC_MYSTICISM = 13618,            // '25',
	FUNC_PC_RESTORATION = 13874,          // '26',
	FUNC_PC_ALCHEMY = 14130,              // '27',
	FUNC_PC_UNARMORED = 14386,            // '28',
	FUNC_PC_SECURITY = 14642,             // '29',
	FUNC_PC_SNEAK = 12339,                // '30',
	FUNC_PC_ACROBATICS = 12595,           // '31',
	FUNC_PC_LIGHT_ARMOR = 12851,          // '32',
	FUNC_PC_SHORT_BLADE = 13107,          // '33',
	FUNC_PC_MARKSMAN = 13363,             // '34',
	FUNC_PC_MERCANTILE = 13619,           // '35',
	FUNC_PC_SPEECHCRAFT = 13875,          // '36',
	FUNC_PC_HAND_TO_HAND = 14131,         // '37',
	FUNC_PC_SEX = 14387,                  // '38',
	FUNC_PC_EXPELLED = 14643,             // '39',
	FUNC_PC_COMMON_DISEASE = 12340,       // '40',
	FUNC_PC_BLIGHT_DISEASE = 12596,       // '41',
	FUNC_PC_CLOTHING_MODIFIER = 12852,    // '42',
	FUNC_PC_CRIME_LEVEL = 13108,          // '43',
	FUNC_SAME_SEX = 13364,                // '44',
	FUNC_SAME_RACE = 13620,               // '45',
	FUNC_SAME_FACTION = 13876,            // '46',
	FUNC_FACTION_RANK_DIFFERENCE = 14132, // '47',
	FUNC_DETECTED = 14388,                // '48',
	FUNC_ALARMED = 14644,                 // '49',
	FUNC_CHOICE = 12341,                  // '50',
	FUNC_PC_INTELLIGENCE = 12597,         // '51',
	FUNC_PC_WILLPOWER = 12853,            // '52',
	FUNC_PC_AGILITY = 13109,              // '53',
	FUNC_PC_SPEED = 13365,                // '54',
	FUNC_PC_ENDURANCE = 13621,            // '55',
	FUNC_PC_PERSONALITY = 13877,          // '56',
	FUNC_PC_LUCK = 14133,                 // '57',
	FUNC_PC_CORPRUS = 14389,              // '58',
	FUNC_WEATHER = 14645,                 // '59',
	FUNC_PC_VAMPIRE = 12342,              // '60',
	FUNC_LEVEL = 12598,                   // '61',
	FUNC_ATTACKED = 12854,                // '62',
	FUNC_TALKED_TO_PC = 13110,            // '63',
	FUNC_PC_HEALTH = 13366,               // '64',
	FUNC_CREATURE_TARGET = 13622,         // '65',
	FUNC_FRIEND_HIT = 13878,              // '66',
	FUNC_FIGHT = 14134,                   // '67',
	FUNC_HELLO = 14390,                   // '68',
	FUNC_ALARM = 14646,                   // '69',
	FUNC_FLEE = 12343,                    // '70',
	FUNC_SHOULD_ATTACK = 12599,           // '71',
	FUNC_WEREWOLF = 12855,                // '72',
	FUNC_WEREWOLF_KILLS = 13111,          // '73',
	FUNC_NOT_CLASS = 22595,               // 'CX',
	FUNC_DEAD_TYPE = 22596,               // 'DX',
	FUNC_NOT_FACTION = 22598,             // 'FX',
	FUNC_ITEM_TYPE = 22601,               // 'IX',
	FUNC_JOURNAL_TYPE = 22602,            // 'JX',
	FUNC_NOT_CELL = 22604,                // 'LX',
	FUNC_NOT_RACE = 22610,                // 'RX',
	FUNC_NOT_ID_TYPE = 22616,             // 'XX',
	FUNC_GLOBAL = 22630,                  // 'fX',
	FUNC_PCGOLD = 22636,                  // 'lX',
	FUNC_COMPARE_GLOBAL = 22578,          // '2X',
	FUNC_COMPARE_LOCAL = 22579,           // '3X',
	FUNC_VARIABLE_COMPARE = 22643,        // 'sX',
} DialogueVarFunc;

typedef enum <char> {
	COMP_EQUAL = '0',
	COMP_NOT_EQUAL = '1',
	COMP_GREATER = '2',
	COMP_GREATER_EQUAL = '3',
	COMP_LESS = '4',
	COMP_LESS_EQUAL = '5',
} DialogueVarComp;

void INFO_INAM(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "thisID";
	sr.displayValue = value;
	parentof(sr).displayName = "Dialogue Info: " + value;
}

void INFO_PNAM(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "prevID";
	sr.displayValue = value;
}

void INFO_NNAM(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "nextID";
	sr.displayValue = value;
}

void INFO_DATA(Subrecord& sr) {
	DialogueType type;
	int disposition;
	byte speakerRank;
	Sex speakerSex;
	byte playerRank;
	byte padding;
	sr.displayName = "data";
}

void INFO_ONAM(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "speaker";
	sr.displayValue = value;
}

void INFO_RNAM(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "speakerRace";
	sr.displayValue = value;
}

void INFO_CNAM(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "speakerClass";
	sr.displayValue = value;
}

void INFO_FNAM(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "speakerFaction";
	sr.displayValue = value;
}

void INFO_ANAM(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "speakerCell";
	sr.displayValue = value;
}

void INFO_DNAM(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "playerFaction";
	sr.displayValue = value;
}

void INFO_NAME(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "text";
	sr.displayValue = value;
}

void INFO_SNAM(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "soundPath";
	sr.displayValue = value;
}

void INFO_QSTN(Subrecord& sr) {
	ubyte value;
	sr.displayName = "isQuestName";
	sr.displayValue = value ? "true" : "false";
}

void INFO_QSTF(Subrecord& sr) {
	ubyte value;
	sr.displayName = "isQuestFinished";
	sr.displayValue = value ? "true" : "false";
}

void INFO_QSTR(Subrecord& sr) {
	ubyte value;
	sr.displayName = "isQuestRestart";
	sr.displayValue = value ? "true" : "false";
}

void INFO_SCVR(Subrecord& sr) {
	char index;
	DialogueVarType type;
	DialogueVarFunc function;
	DialogueVarComp compare;
	char variableName[sr.size - 5];  // remaining bytes
	sr.displayName = "variableInfo";
}

void INFO_FLTV(Subrecord& sr) {
	float value;
	sr.displayName = "variableValue";
	SPrintf(sr.displayValue, "%.4f", value);
}

void INFO_INTV(Subrecord& sr) {
	int value;
	sr.displayName = "variableValue";
	SPrintf(sr.displayValue, "%d", value);
}

void INFO_BNAM(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "scriptText";
	sr.displayValue = value;
}

void SubrecordFactory_INFO(Subrecord& sr) {
	switch (sr.tag) {
		case "INAM": INFO_INAM(sr); break;
		case "PNAM": INFO_PNAM(sr); break;
		case "NNAM": INFO_NNAM(sr); break;
		case "DATA": INFO_DATA(sr); break;
		case "ONAM": INFO_ONAM(sr); break;
		case "RNAM": INFO_RNAM(sr); break;
		case "CNAM": INFO_CNAM(sr); break;
		case "FNAM": INFO_FNAM(sr); break;
		case "ANAM": INFO_ANAM(sr); break;
		case "DNAM": INFO_DNAM(sr); break;
		case "NAME": INFO_NAME(sr); break;
		case "SNAM": INFO_SNAM(sr); break;
		case "QSTN": INFO_QSTN(sr); break;
		case "QSTF": INFO_QSTF(sr); break;
		case "QSTR": INFO_QSTR(sr); break;
		case "SCVR": INFO_SCVR(sr); break;
		case "FLTV": INFO_FLTV(sr); break;
		case "INTV": INFO_INTV(sr); break;
		case "BNAM": INFO_BNAM(sr); break;
		default: byte undefined[sr.size];
	}
}

//
// Record: SSCR (Start Script)
//

void SSCR_DATA(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "ID";
	parentof(sr).displayName = "Start Script: " + value;
}

void SSCR_NAME(Subrecord& sr) {
	char value[sr.size];
	sr.displayName = "Script ID";
	sr.displayValue = value;
	parentof(sr).displayValue = value;
}

void SubrecordFactory_SSCR(Subrecord& sr) {
	switch (sr.tag) {
		case "DATA": SSCR_DATA(sr); break;
		case "NAME": SSCR_NAME(sr); break;
		default: byte undefined[sr.size];
	}
}

//
// Begin actual reading.
//

while (!FEof()) {
	Record record;
}
