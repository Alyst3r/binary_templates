LittleEndian();


/* -- Enums -- */


typedef enum {
    ALPHA_NONE,
    BINARY,
    SMOOTH,
    ALPHA_DEFAULT,
} AlphaFormat;


typedef enum {
    APPLY_REPLACE,
    APPLY_DECAL,
    APPLY_MODULATE,
    APPLY_HILIGHT,
    APPLY_HILIGHT2,
} ApplyMode;


typedef enum {
    XYZ,
    XZY,
    YZX,
    YXZ,
    ZXY,
    ZYX,
    XYX,
    YZY,
    ZXZ,
} AxisOrder;


typedef enum {
    NEGATIVE = -1,
    POSITIVE = 1,
} BankDirection;


typedef enum {
    BASE_BV = -1,
    SPHERE_BV,
    BOX_BV,
    CAPSULE_BV,
    LOZENGE_BV,
    UNION_BV,
    HALFSPACE_BV,
} BoundType;


typedef enum {
    CLAMP_S_CLAMP_T,
    CLAMP_S_WRAP_T,
    WRAP_S_CLAMP_T,
    WRAP_S_WRAP_T,
} ClampMode;


typedef enum {
    WORLD_PARALLEL,
    WORLD_PERSPECTIVE,
    SPHERE_MAP,
    SPECULAR_CUBE_MAP,
    DIFFUSE_CUBE_MAP,
} CoordGenType;


typedef enum {
    DECAY_NONE,
    LINEAR,
    EXPONENTIAL,
} DecayType;


typedef enum {
    FILTER_NEAREST,
    FILTER_BILERP,
    FILTER_TRILERP,
    FILTER_NEAREST_MIPNEAREST,
    FILTER_NEAREST_MIPLERP,
    FILTER_BILERP_MIPNEAREST,
} FilterMode;


typedef enum {
    FORCE_PLANAR,
    FORCE_SPHERICAL,
} ForceType;


typedef enum {
    NOINTERP,
    LINKEY,
    BEZKEY,
    TCBKEY,
    EULERKEY,
} KeyType;


typedef enum {
    LIGHTING_E,
    LIGHTING_E_A_D,
} LightingMode;


typedef enum {
    RGB,
    RGBA,
    PAL,
    PALALPHA,
    COMPRESS1,
    COMPRESS3,
    COMPRESS5,
    RGB24NONINTERLEAVED,
    BUMP,
    BUMPLUMA,
} PixelFormat;


typedef enum {
    PALETTIZED_8,
    HIGH_COLOR_16,
    TRUE_COLOR_32,
    COMPRESSED,
    BUMPMAP,
    PALETTIZED_4,
    PIX_DEFAULT,
} PixelLayout;


typedef enum {
    SORTING_INHERIT,
    SORTING_OFF,
    SORTING_SUBSORT,
} SortingMode;


typedef enum {
    SOURCE_IGNORE,
    SOURCE_EMISSIVE,
    SOURCE_AMB_DIFF,
} SourceVertexMode;


typedef enum {
    SPHERICAL,
    CYLINDRICAL,
    PLANAR,
} SymmetryType;


typedef enum {
    PROJECTED_LIGHT,
    PROJECTED_SHADOW,
    ENVIRONMENT_MAP,
    FOG_MAP,
} TextureType;


typedef enum {
    NO,
    YES,
    MIP_DEFAULT,
} UseMipMaps;


/* -- Basic Types -- */


typedef uint NiBool <read=NiBool_read>;


typedef struct {
    uint size;
    char value[size];
} NiString <read=NiString_read>;



/* -- Math Types -- */


typedef struct {
    float x;
    float y;
} NiPoint2;


typedef struct {
    float x;
    float y;
    float z;
} NiPoint3;


typedef struct {
    NiPoint2 col0;
    NiPoint2 col1;
} NiMatrix2;


typedef struct {
    NiPoint3 col0;
    NiPoint3 col1;
    NiPoint3 col2;
} NiMatrix3;


typedef struct {
    float w;
    float x;
    float y;
    float z;
} NiQuaternion;


typedef struct {
    float r;
    float g;
    float b;
} NiColor;


typedef struct {
    float r;
    float g;
    float b;
    float a;
} NiColorA;


typedef struct {
    NiPoint3 normal;
    float constant;
} NiPlane;


typedef struct {
    float left;
    float right;
    float top;
    float bottom;
} NiRect;


typedef struct {
    float left;
    float right;
    float top;
    float bottom;
    float near;
    float far;
} NiFrustum;


/* -- NiObject Types -- */


typedef struct {
    // no fields
} NiObject;


typedef struct {
    NiObject super;
} NiAccumulator;


typedef struct {
    NiAccumulator super;
} NiClusterAccumulator;


typedef struct {
    NiClusterAccumulator super;
} NiAlphaAccumulator;


typedef struct {
    NiObject super;
    int nextExtraData;
    uint bytesRemaining;
} NiExtraData;


typedef struct {
    NiExtraData super;
} TES3ObjectExtraData;


typedef struct {
    NiExtraData super;
    NiString stringData;
} NiStringExtraData;


typedef struct {
    float time;
    NiString value;
} NiTextKey <optimize=false>;  // not NiObject derived


typedef struct {
    NiExtraData super;
    uint numTextKeys;
    NiTextKey textKeys[numTextKeys];
} NiTextKeyExtraData;


typedef struct {
    NiExtraData super;
    ushort numWeights;
    float weights[numWeights];
} NiVertWeightsExtraData;


typedef struct {
    NiObject super;
    ushort numVertices;
    NiBool hasVertices;
    if (hasVertices) {
        NiPoint3 vertices[numVertices];
    }
    NiBool hasNormals;
    if (hasNormals) {
        NiPoint3 normals[numVertices];
    }
    float center;
    NiPoint3 radius;
    NiBool hasVertexColors;
    if (hasVertexColors) {
        NiColorA vertexColors[numVertices];
    }
    ushort numUVSets;
    NiBool hasUVSets;
    if (hasUVSets) {
        NiPoint2 UVSets[numUVSets * numVertices];
    }
} NiGeometryData;


typedef struct {
    NiGeometryData super;
    ubyte vertexFlags[super.numVertices];
} NiLinesData;


typedef struct {
    NiGeometryData super;
    ushort activeTriangles;
} NiTriBasedGeomData;


typedef struct {
    NiTriBasedGeomData super;
    float particleRadius;
    ushort numActive;
    NiBool hasSizes;
    if (hasSizes) {
        float sizes[super.super.numVertices];
    }
} NiParticlesData;  // TODO needs confirmation


typedef struct {
    NiParticlesData super;
} NiAutoNormalParticlesData;


typedef struct {
    NiParticlesData super;
    NiBool hasRotations;
    if (hasRotations) {
        NiQuaternion rotations[super.super.super.numVertices];
    }
} NiRotatingParticlesData;


typedef struct {
    NiTriBasedGeomData super;
    uint numTrianglePoints;
    ushort triangles[numTrianglePoints];
    ushort numSharedNormals;
    struct {
        ushort numVertexIndices;
        ushort vertexIndices[numVertexIndices];
    } sharedNormals[numSharedNormals] <optimize=false>;
} NiTriShapeData;


typedef struct {
    NiTriShapeData super;
    ushort activeVertices;
    ushort activeTriangles;
} NiTriShapeDynamicData;


typedef struct {
    NiTriBasedGeomData super;
    ushort numStrips;
    ushort stripLengths[numStrips];
    for (i = 0; i < numStrips; i++) {
        ushort strips[numStrips[i]];
    }
} NiTriStripsData;


typedef struct {
    NiObject super;
    NiString name;
    int controller;
    int extra_data;
} NiObjectNET;


typedef struct {
    NiObjectNET super;
} NiSequenceStreamHelper;


typedef struct {
    NiObjectNET super;
} NiTexture;


typedef struct {
    NiTexture super;
    ubyte hasExternal;
    if (hasExternal) {
        NiString fileName;
    } else {
        ubyte hasPixelData;
        if (hasPixelData) {
            int pixelData;
        }
    }
    PixelLayout pixelLayout;
    UseMipMaps useMipMaps;
    AlphaFormat alphaFormat;
    ubyte isStatic;
} NiSourceTexture;


typedef struct {
    NiObjectNET super;
    ushort flags;
} NiProperty;


typedef struct {
    NiProperty super;
    ubyte testRef;
} NiAlphaProperty;


typedef struct {
    NiProperty super;
} NiDitherProperty;


typedef struct {
    NiProperty super;
    float fogDepth;
    NiColor fogColor;
} NiFogProperty;


typedef struct {
    NiProperty super;
    NiColor ambientColor;
    NiColor diffuseColor;
    NiColor specularColor;
    NiColor emissiveColor;
    float shine;
    float alpha;
} NiMaterialProperty;


typedef struct {
    NiProperty super;
    int unknown;
} NiRendererSpecificProperty;


typedef struct {
    NiProperty super;
} NiShadeProperty;


typedef struct {
    NiProperty super;
} NiSpecularProperty;


typedef struct {
    NiProperty super;
    ubyte stencilEnabled;
    uint stencilFunction;
    uint stencilRef;
    uint stencilMask;
    uint failAction;
    uint passZFailAction;
    uint passAction;
    uint drawMode;
} NiStencilProperty;


typedef struct {
    int source;
    ClampMode clampMode;
    FilterMode filterMode;
    uint uvSet;
    short ps2L;
    short ps2K;
    ubyte unknown1;
    ubyte unknown2;
} NiTexturingProperty_Map;  // not NiObject derived


typedef struct {
    NiTexturingProperty_Map super;
    float lumaScale;
    float lumaOffset;
    NiMatrix2 displacement;
} NiTexturingProperty_BumpMap;  // not NiObject derived


typedef struct {
    NiProperty super;
    ApplyMode applyMode;
    uint numTextureMaps;
    local uint i;
    for (i = 0; i < numTextureMaps; i++) {
        NiBool hasMap;
        if (hasMap) {
            if (i == 5) {  // BumpMapIndex
                NiTexturingProperty_BumpMap bumpMap;
            } else {
                NiTexturingProperty_Map map;
            }
        }
    }
} NiTexturingProperty;


typedef struct {
    NiProperty super;
    SourceVertexMode sourceVertexMode;
    LightingMode lightingMode;
} NiVertexColorProperty;


typedef struct {
    NiProperty super;
} NiWireframeProperty;


typedef struct {
    NiProperty super;
} NiZBufferProperty;


typedef struct {
    NiPoint3 center;
    float radius;
} NiSphereBV;  // not NiObject derived


typedef struct {
    NiPoint3 center;
    NiMatrix3 rotation;
    NiPoint3 extents;
} NiBoxBV;  // not NiObject derived


typedef struct {
    uint numBoundingVolumes;
    struct NiBoundingVolume boundingVolumes[numBoundingVolumes];
} NiUnionBV <optimize=false>;  // not NiObject derived


typedef struct {
    BoundType boundType;
    switch (boundType) {
        case SPHERE_BV: NiSphereBV boundingVolume; break;
        case BOX_BV: NiBoxBV boundingVolume; break;
        case UNION_BV: NiUnionBV boundingVolume; break;
        default:
            Assert(false);  // TODO other bound types
    }
} NiBoundingVolume <optimize=false>;  // not NiObject derived


typedef struct {
    NiObjectNET super;
    ushort flags;
    NiPoint3 translation;
    NiMatrix3 rotation;
    float scale;
    NiPoint3 velocity;
    uint numProperties;
    int properties[numProperties];
    NiBool hasBoundingVolume;
    if (hasBoundingVolume) {
        NiBoundingVolume boundingVolume;
    }
} NiAVObject;


typedef struct {
    NiAVObject super;
    NiFrustum viewFrustum;
    NiRect viewPort;
    float lodAdjust;
    int scene;
    uint numScreenPolygons;
    uint screenPolygons[numScreenPolygons];
} NiCamera;


typedef struct {
    NiAVObject super;
    uint numAffectedNodes;
    int affectedNodes[numAffectedNodes];
} NiDynamicEffect;


typedef struct {
    NiDynamicEffect super;
    NiMatrix3 modelProjectionMatrix;
    NiPoint3 modelProjectionTranslation;
    FilterMode textureFiltering;
    ClampMode textureClamping;
    TextureType textureType;
    CoordGenType coordinateGenerationType;
    int sourceTexture;
    ubyte clippingPlaneEnable;
    NiRect clippingPlane;
    ushort ps2L;
    ushort ps2K;
    ubyte unknown1;
    ubyte unknown2;
} NiTextureEffect;


typedef struct {
    NiDynamicEffect super;
    float dimmer;
    NiColor ambient_color;
    NiColor diffuse_color;
    NiColor specular_color;
} NiLight;


typedef struct {
    NiLight super;
} NiAmbientLight;


typedef struct {
    NiLight super;
} NiDirectionalLight;


typedef struct {
    NiLight super;
    float constantAttenuation;
    float linearAttenuation;
    float quadraticAttenuation;
} NiPointLight;


typedef struct {
    NiPointLight super;
    float outerSpotAngle;
    float exponent;
} NiSpotLight;


typedef struct {
    NiAVObject super;
    int geometryData;
    int skinInstance;
} NiGeometry;


typedef struct {
    NiGeometry super;
} NiLines;


typedef struct {
    NiGeometry super;
} NiTriBasedGeom;


typedef struct {
    NiTriBasedGeom super;
} NiTriShape;


typedef struct {
    NiTriBasedGeom super;
} NiParticles;


typedef struct {
    NiParticles super;
} NiAutoNormalParticles;


typedef struct {
    NiParticles super;
} NiRotatingParticles;


typedef struct {
    NiTriBasedGeom super;
} NiTriStrips;


typedef struct {
    NiAVObject super;
    uint numChildren;
    int children[numChildren];
    uint numEffects;
    int effects[numEffects];
} NiNode;


typedef struct {
    NiNode super;
} AvoidNode;  // Bethesda


typedef struct {
    NiNode super;
} BSMirroredNode;  // Bethesda


typedef struct {
    NiNode super;
} RootCollisionNode;  // Bethesda


typedef struct {
    NiNode super;
} NiBillboardNode;


typedef struct {
    NiNode super;
} NiBSAnimationNode;  // Bethesda


typedef struct {
    NiNode super;
} NiBSAnimationManager;  // Bethesda


typedef struct {
    NiNode super;
} NiBSParticleNode;  // Bethesda


typedef struct {
    NiNode super;
    NiPlane modelPlane;
} NiBSPNode;


typedef struct {
    NiNode super;
} NiCollisionSwitch;


typedef struct {
    NiNode super;
    SortingMode sortingMode;
    int subSorter;
} NiSortAdjustNode;


typedef struct {
    NiNode super;
    uint activeIndex;
} NiSwitchNode;


typedef struct {
    NiSwitchNode super;
    float period;
} NiFltAnimationNode;


typedef struct {
    NiSwitchNode super;
    NiPoint3 LODCenter;
    uint numLODLevels;
    float LODLevels[numLODLevels * 2];
} NiLODNode;


typedef struct {
    NiObject super;
    int nextModifier;
    int controller;
} NiParticleModifier;


typedef struct {
    NiParticleModifier super;
    float decay;
    float strength;
    ForceType forceType;
    NiPoint3 position;
    NiPoint3 direction;
} NiGravity;


typedef struct {
    NiParticleModifier super;
    float decay;
    float duration;
    float delta_v;
    float start_time;
    DecayType decayType;
    SymmetryType symmetryType;
    NiPoint3 position;
    NiPoint3 direction;
} NiParticleBomb;


typedef struct {
    NiParticleModifier super;
    float bounce;
} NiParticleCollider;


typedef struct {
    NiParticleCollider super;
    float height;
    float width;
    NiPoint3 position;
    NiPoint3 x_axis;
    NiPoint3 y_axis;
    NiPlane plane;
} NiPlanarCollider;


typedef struct {
    NiParticleCollider super;
    float radius;
    NiPoint3 position;
} NiSphericalCollider;


typedef struct {
    NiParticleModifier super;
    int colorData;
} NiParticleColorModifier;


typedef struct {
    NiParticleModifier super;
    float growTime;
    float fadeTime;
} NiParticleGrowFade;


typedef struct {
    NiParticleModifier super;
    ubyte randomInitialAxis;
    NiPoint3 initialAxis;
    float rotationSpeed;
} NiParticleRotation;


typedef struct {
    PixelFormat pixelFormat;
    uint colorMasks[4];
    uint bitsPerPixel;
    ubyte oldFastCompare[8];
} NiPixelFormat;  // not NiObject derived


typedef struct {
    NiObject super;
    NiPixelFormat pixelFormat;
    int palette;
    uint numMipMapLevels;
    uint pixelStride;
    uint mipMaps[numMipMapLevels * 3];
    uint numPixels;
    ubyte pixelData[numPixels];
} NiPixelData;


typedef struct {
    NiObject super;
    int nextController;
    ushort flags;
    float frequency;
    float phase;
    float startTime;
    float stopTime;
    int target;
} NiTimeController;


typedef struct {
    NiTimeController super;
    uint affectedMap;
    float unknown;
    float secsPerFrame;
    uint numTextures;
    int textures[numTextures];
} NiFlipController;


typedef struct {
    NiTimeController super;
    int floatData;
} NiFloatController;


typedef struct {
    NiFloatController super;
} NiAlphaController;


typedef struct {
    NiFloatController super;
} NiRollController;


typedef struct {
    NiTimeController super;
    int keyframeData;
} NiKeyframeController;


typedef struct {
    NiString sequenceName;
    ubyte hasExternal;
    if (hasExternal) {
        NiString keyframeFile;
    } else {
        int unknown1;
        int unknown2;  // link?
    }
    uint numTargets;
    struct {
        NiString targetName;
        int targetController;
    } targets[numTargets] <optimize=false>;
} NiSequence <optimize=false>;  // not NiObject derived


typedef struct {
    NiTimeController super;
    uint numSequences;
    NiSequence sequences[numSequences];
} NiKeyframeManager;


typedef struct {
    NiTimeController super;
    int lightColorData;
} NiLightColorController;


typedef struct {
    NiTimeController super;
    int lookAt;
} NiLookAtController;


typedef struct {
    NiTimeController super;
    int materialColorData;
} NiMaterialColorController;


typedef struct {
    NiTimeController super;
    int morpherData;
} NiMorpherController;


typedef struct {
    NiMorpherController super;
    ubyte alwaysUpdate;
} NiGeomMorpherController;


typedef struct {
    NiPoint3 velocity;
    NiPoint3 rotation_axis;
    float age;
    float lifespan;
    float last_update;
    ushort generation;
    ushort index;
} NiPerParticleData;  // not NiObject derived


typedef struct {
    NiTimeController super;
    float speed;
    float speedVariation;
    float declinationAngle;
    float declinationVariation;
    float planarAngle;
    float planarAngleVariation;
    NiPoint3 initialNormal;
    NiColorA initialColor;
    float initialSize;
    float emitStartTime;
    float emitStopTime;
    ubyte resetParticleSystem;
    float birthRate;
    float lifespan;
    float lifespanVariation;
    ubyte useBirthRate;
    ubyte spawnOnDeath;
    float emitterWidth;
    float emitterHeight;
    float emitterDepth;
    int emitter;
    ushort spawnGenerations;
    float spawnPercentage;
    ushort spawnMultiplier;
    float spawnedSpeedChaos;
    float spawnedDirectionChaos;
    ushort numParticles;
    ushort numActiveParticles;
    NiPerParticleData particles[numParticles];
    int emitterModifier;
    int particleModifier;
    int particleCollider;
    ubyte computeDynamicBoundingVolume;
} NiParticleSystemController;


typedef struct {
    NiParticleSystemController super;
} NiBSPArrayController;


typedef struct {
    NiTimeController super;
    BankDirection bankDirection;
    float maxBankAngle;
    float smoothing;
    ushort followAxis;
    int pathData;
    int percentageData;
} NiPathController;


typedef struct {
    NiTimeController super;
    ushort textureSet;
    int UVData;
} NiUVController;


typedef struct {
    NiTimeController super;
    int visData;
} NiVisController;


typedef struct {
    float time;
    float value;
} NiFloatKey;  // not NiObject derived


typedef struct {
    float time;
    float value;
    float inTan;
    float outTan;
} NiBezFloatKey;  // not NiObject derived


typedef struct {
    float time;
    float value;
    float tcb[3];
} NiTCBFloatKey;  // not NiObject derived


typedef struct {
    NiObject super;
    uint numKeys;
    if (numKeys) {
        KeyType keyType;
        switch (keyType) {
            case NOINTERP:
                NiFloatKey keys[numKeys]; break;
            case LINKEY:
                NiFloatKey keys[numKeys]; break;
            case BEZKEY:
                NiBezFloatKey keys[numKeys]; break;
            case TCBKEY:
                NiTCBFloatKey keys[numKeys]; break;
            default:
                Assert(false);  // invalid interpolation
        }
    }
} NiFloatData;


typedef struct {
    float time;
    NiColorA value;
} NiColorAKey;  // not NiObject derived


typedef struct {
    NiObject super;
    uint numKeys;
    if (numKeys) {
        KeyType keyType;
        switch (keyType) {
            case NOINTERP:
                NiColorAKey keys[numKeys]; break;
            case LINKEY:
                NiColorAKey keys[numKeys]; break;
            default:
                Assert(false);  // invalid interpolation
        }
    }
} NiColorData;


typedef struct {
    float time;
    NiPoint3 value;
} NiPosKey;  // not NiObject derived


typedef struct {
    float time;
    NiPoint3 value;
    NiPoint3 inTan;
    NiPoint3 outTan;
} NiBezPosKey;  // not NiObject derived


typedef struct {
    float time;
    NiPoint3 value;
    float tcb[3];
} NiTCBPosKey;  // not NiObject derived


typedef struct {
    NiObject super;
    uint numKeys;
    if (numKeys) {
        KeyType keyType;
        switch (keyType) {
            case NOINTERP:
                NiPosKey keys[numKeys]; break;
            case LINKEY:
                NiPosKey keys[numKeys]; break;
            case BEZKEY:
                NiBezPosKey keys[numKeys]; break;
            case TCBKEY:
                NiTCBPosKey keys[numKeys]; break;
            default:
                Assert(false);  // invalid interpolation
        }
    }
} NiPosData;


typedef struct {
    float time;
    NiQuaternion value;
} NiRotKey;  // not NiObject derived


typedef struct {
    float time;
    NiQuaternion value;
} NiBezRotKey;  // not NiObject derived


typedef struct {
    float time;
    NiQuaternion value;
    float tcb[3];
} NiTCBRotKey;  // not NiObject derived


typedef struct {
    AxisOrder axisOrder;
    NiFloatData eulerData[3];
} NiEulerRotKey;  // not NiObject derived


typedef struct {
    NiObject super;
    uint numKeys;
    if (numKeys) {
        KeyType keyType;
        switch (keyType) {
            case NOINTERP:
                NiRotKey keys[numKeys]; break;
            case LINKEY:
                NiRotKey keys[numKeys]; break;
            case BEZKEY:
                NiBezRotKey keys[numKeys]; break;
            case TCBKEY:
                NiTCBRotKey keys[numKeys]; break;
            case EULERKEY:
                NiEulerRotKey keys[numKeys]; break;
            default:
                Assert(false);  // invalid interpolation
        }
    }
} NiRotData;


typedef struct {
    NiObject super;
    NiRotData rotations;
    NiPosData translations;
    NiFloatData scales;
} NiKeyframeData;


typedef struct {
    uint numKeys;
    KeyType keyType;
    if (numKeys) {
        switch (keyType) {
            case NOINTERP:
                NiFloatKey keys[numKeys]; break;
            case LINKEY:
                NiFloatKey keys[numKeys]; break;
            case BEZKEY:
                NiBezFloatKey keys[numKeys]; break;
            case TCBKEY:
                NiTCBFloatKey keys[numKeys]; break;
            default:
                Assert(false);  // invalid interpolation
        }
    }
    NiPoint3 vertices[parentof(this).numVertices];
} NiMorphData_MorphTarget <optimize=false>;  // not NiObject derived


typedef struct {
    NiObject super;
    uint numTargets;
    uint numVertices;
    ubyte relativeTargets;
    NiMorphData_MorphTarget targets[numTargets];
} NiMorphData;


typedef struct {
    NiObject super;
    ubyte hasAlpha;
    uint numPalettes;
    ubyte palettes[numPalettes * 4];
} NiPalette;


typedef struct {
    NiMatrix3 rotation;
    NiPoint3 translation;
    float scale;
    NiPoint3 center;
    float radius;
    ushort numVertexWeights;
    struct {
        ushort vertexIndex;
        float vertexWeight;
    } vertexWeights[numVertexWeights];
} NiSkinData_BoneData <optimize=false>;  // not NiObject derived


typedef struct {
    NiObject super;
    NiMatrix3 rotation;
    NiPoint3 translation;
    float scale;
    uint numBones;
    int skinPartition;
    NiSkinData_BoneData boneData[numBones];
} NiSkinData;


typedef struct {
    NiObject super;
    int skinData;
    int root;
    uint numBones;
    int bones[numBones];;
} NiSkinInstance;


typedef struct {
    ushort numVertices;
    ushort numTriangles;
    ushort numBones;
    ushort numStrips;
    ushort numBonesPerVertex;
    ushort bones[numBones];
    ushort vertexMap[numVertices];
    float weights[numBonesPerVertex * numVertices];
    if (numStrips) {
        ushort stripLengths[numStrips];
        local uint stripLengthsSum = 0;
        local uint i = 0;
        for (i = 0; i < numStrips; i++) {
            stripLengthsSum += stripLengths[i];
        }
        ushort triangles[stripLengthsSum];
    } else {
        ushort triangles[numTriangles * 3];
    }
    ubyte hasPalette;
    if (hasPalette) {
        ubyte bonePalette[numBonesPerVertex * numVertices];
    }
} NiSkinPartition_SkinPartition <optimize=false>;  // not NiObject derived


typedef struct {
    NiObject super;
    uint numSkinPartitions;
    NiSkinPartition_SkinPartition skinPartitions[numSkinPartitions];
} NiSkinPartition;


typedef struct {
    NiObject super;
    NiFloatData offset_u;
    NiFloatData offset_v;
    NiFloatData tiling_u;
    NiFloatData tiling_v;
} NiUVData;


typedef struct {
    float time;
    ubyte value;
} NiVisKey;  // not NiObject derived


typedef struct {
    NiObject super;
    uint numKeys;
    NiVisKey keys[numKeys];
} NiVisData;


typedef struct {
    NiObject super;
} NiEmitterModifier;  // TODO needs confirmation


/* -- Functions -- */


string NiBool_read(NiBool &self) {
    return self ? "true" : "false";
}

string NiString_read(NiString &self) {
    return self.size ? self.value : "";
}


/* -- Begin Parsing -- */


struct {
    char header[40];
    uint version <format=hex>;
    uint numObjects;
} header;


local uint i;
for (i = 0; i < header.numObjects; i++) {
    NiString objectType;
    switch (objectType.value) {
        case "NiObject": NiObject object; break;

        case "NiAccumulator": NiAccumulator object; break;
        case "NiClusterAccumulator": NiClusterAccumulator object; break;
        case "NiAlphaAccumulator": NiAlphaAccumulator object; break;

        case "NiExtraData": NiExtraData object; break;
        case "TES3ObjectExtraData": TES3ObjectExtraData object; break;
        case "NiStringExtraData": NiStringExtraData object; break;
        case "NiTextKeyExtraData": NiTextKeyExtraData object; break;
        case "NiVertWeightsExtraData": NiVertWeightsExtraData object; break;

        case "NiGeometryData": NiGeometryData object; break;
        case "NiTriBasedGeomData": NiTriBasedGeomData object; break;
        case "NiLinesData": NiLinesData object; break;
        case "NiParticlesData": NiParticlesData object; break;
        case "NiAutoNormalParticlesData": NiAutoNormalParticlesData object; break;
        case "NiRotatingParticlesData": NiRotatingParticlesData object; break;
        case "NiTriShapeData": NiTriShapeData object; break;
        case "NiTriShapeDynamicData": NiTriShapeDynamicData object; break;
        case "NiTriStripsData": NiTriStripsData object; break;

        case "NiObjectNET": NiObjectNET object; break;
        case "NiSequenceStreamHelper": NiSequenceStreamHelper object; break;

        case "NiTexture": NiTexture object; break;
        // case "NiRenderedTexture": NiRenderedTexture object; break;
        // case "NiRenderedCubeMap": NiRenderedCubeMap object; break;
        case "NiSourceTexture": NiSourceTexture object; break;

        case "NiProperty": NiProperty object; break;
        case "NiAlphaProperty": NiAlphaProperty object; break;
        case "NiDitherProperty": NiDitherProperty object; break;
        case "NiFogProperty": NiFogProperty object; break;
        case "NiMaterialProperty": NiMaterialProperty object; break;
        case "NiRendererSpecificProperty": NiRendererSpecificProperty object; break;
        case "NiShadeProperty": NiShadeProperty object; break;
        case "NiSpecularProperty": NiSpecularProperty object; break;
        case "NiStencilProperty": NiStencilProperty object; break;
        case "NiTexturingProperty": NiTexturingProperty object; break;
        case "NiVertexColorProperty": NiVertexColorProperty object; break;
        case "NiWireframeProperty": NiWireframeProperty object; break;
        case "NiZBufferProperty": NiZBufferProperty object; break;

        case "NiAVObject": NiAVObject object; break;
        case "NiCamera": NiCamera object; break;

        case "NiDynamicEffect": NiDynamicEffect object; break;
        case "NiTextureEffect": NiTextureEffect object; break;
        case "NiLight": NiLight object; break;
        case "NiAmbientLight": NiAmbientLight object; break;
        case "NiDirectionalLight": NiDirectionalLight object; break;
        case "NiPointLight": NiPointLight object; break;
        case "NiSpotLight": NiSpotLight object; break;

        case "NiGeometry": NiGeometry object; break;
        case "NiLines": NiLines object; break;
        case "NiTriBasedGeomData": NiTriBasedGeomData object; break;
        case "NiTriShape": NiTriShape object; break;
        case "NiParticles": NiParticles object; break;
        case "NiAutoNormalParticles": NiAutoNormalParticles object; break;
        case "NiRotatingParticles": NiRotatingParticles object; break;
        case "NiTriStrips": NiTriStrips object; break;

        case "NiNode": NiNode object; break;
        case "AvoidNode": AvoidNode object; break;
        case "BSMirroredNode": BSMirroredNode object; break;
        case "RootCollisionNode": RootCollisionNode object; break;
        case "NiBillboardNode": NiBillboardNode object; break;
        case "NiBSAnimationNode": NiBSAnimationNode object; break;
        case "NiBSAnimationManager": NiBSAnimationManager object; break;
        case "NiBSParticleNode": NiBSParticleNode object; break;
        case "NiBSPNode": NiBSPNode object; break;
        case "NiCollisionSwitch": NiCollisionSwitch object; break;
        case "NiSortAdjustNode": NiSortAdjustNode object; break;
        case "NiSwitchNode": NiSwitchNode object; break;
        case "NiFltAnimationNode": NiFltAnimationNode object; break;
        case "NiLODNode": NiLODNode object; break;

        case "NiParticleModifier": NiParticleModifier object; break;
        case "NiGravity": NiGravity object; break;
        case "NiParticleBomb": NiParticleBomb object; break;
        case "NiParticleCollider": NiParticleCollider object; break;
        case "NiPlanarCollider": NiPlanarCollider object; break;
        case "NiSphericalCollider": NiSphericalCollider object; break;
        case "NiParticleColorModifier": NiParticleColorModifier object; break;
        case "NiParticleGrowFade": NiParticleGrowFade object; break;
        case "NiParticleRotation": NiParticleRotation object; break;

        case "NiPixelData": NiPixelData object; break;
        // case "NiBltSource": NiBltSource object; break;

        // case "NiRenderer": NiRenderer object; break;
        // case "NiDX8Renderer": NiDX8Renderer object; break;

        case "NiTimeController": NiTimeController object; break;
        case "NiFlipController": NiFlipController object; break;
        case "NiFloatController": NiFloatController object; break;
        case "NiAlphaController": NiAlphaController object; break;
        case "NiRollController": NiRollController object; break;
        case "NiKeyframeController": NiKeyframeController object; break;
        case "NiKeyframeManager": NiKeyframeManager object; break;
        case "NiLightColorController": NiLightColorController object; break;
        case "NiLookAtController": NiLookAtController object; break;
        case "NiMaterialColorController": NiMaterialColorController object; break;
        case "NiMorpherController": NiMorpherController object; break;
        case "NiGeomMorpherController": NiGeomMorpherController object; break;
        case "NiParticleSystemController": NiParticleSystemController object; break;
        case "NiBSPArrayController": NiBSPArrayController object; break;
        case "NiPathController": NiPathController object; break;
        case "NiUVController": NiUVController object; break;
        case "NiVisController": NiVisController object; break;

        case "NiColorData": NiColorData object; break;
        case "NiEmitterModifier": NiEmitterModifier object; break;
        case "NiFloatData": NiFloatData object; break;
        case "NiKeyframeData": NiKeyframeData object; break;
        case "NiMorphData": NiMorphData object; break;
        case "NiPalette": NiPalette object; break;
        case "NiPosData": NiPosData object; break;
        // case "NiScreenPolygon": NiScreenPolygon object; break;
        case "NiSkinData": NiSkinData object; break;
        case "NiSkinInstance": NiSkinInstance object; break;
        case "NiSkinPartition": NiSkinPartition object; break;
        case "NiUVData": NiUVData object; break;
        case "NiVisData": NiVisData object; break;
    }
}


struct {
    uint numRoots;
    uint roots[numRoots];
} footer;
